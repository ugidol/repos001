 第３章
3.1 エンティティのマッピング方法
3.1.1 Configuration-by-Exception
3.2 基本的なマッピング
3.2.1 テーブル
3.2.2 主キー
3.2.3 属性
3.2.4 アクセスタイプ
3.2.5 基本型のコレクション
3.2.6 基本型のマッピング
3.3 XMLによるマッピング
3.4 組み込み可能オブジェクト
3.4.1 組み込み可能クラスのアクセスタイプ
3.5 リレーションシップ・マッピング
3.5.1 リレーショナル・データベースにおけるリレーションシップ
3.5.2 エンティティのリレーションシップ
3.5.3 リレーションシップのフェッチ
3.5.4 リレーションシップの順序
3.6 継承のマッピング
3.6.1 継承方式
3.6.2 継承階層に含まれるクラスの種類
3.7 まとめ

クラスをエンティティにするための規則
- エンティティクラスに@javax.persistence.Entity アノテーションを付与する
- @javax.persistence.Id アノテーションを付与した主キーを持たせる
- エンティティクラスには public もしくは protected の引数なしコンストラクタが存在する
- 列挙型やインタフェースはエンティティクラスにはできない
- エンティティクラスに対するfinal指定はできない
- エンティティのインスタンスを分離し、オブジェクトとして値で渡す必要がある場合、エンティティクラスはSerializableインタフェースの実装が必要

Configuration-by-Exception
必要な場合のみデフォルト値を上書きするという考え方

@Table
@javax.persistence.Table アノテーションを使用することで、テーブル名等を指定することができる

@SecondaryTable
1つのエンティティを複数のテーブルに格納する場合に使用する。
各メンバ変数の格納先は@Columnアノテーションで指定する

シンプルな主キー
@javax.persistence.Id アノテーションを使用する
@Idアノテーションを使用可能な属性
Javaのプリミティブ型
Javaのプリミティブ型のラッパークラス
プリミティブ型またはラッパー型の配列
文字列型、数値型、日付型

主キーの生成方法
アプリケーション側で生成する、または @GeneratedValueアノテーションを使用する
AUTO, SEQUENCE, ID, TABLE 

複数カラムで主キーを構成する場合
@EmbeddedID または @IdClass アノテーションを使用する
（どちらを使用してもデータベースの構成は変わらない。）
（JPQLを使用してエンティティ参照する際の構文が大きく変わる）

アノテーションはフィールド(メンバ変数)／プロパティ(メンバ変数に対応するgetter/setter)のどちらにも指定することができる。


